<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PC Builder 3D - Simulador de Montagem</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0ff;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 2px solid #0ff;
            border-radius: 10px;
            box-shadow: 0 0 15px #0ff;
            max-width: 300px;
            pointer-events: none; /* Let clicks pass through to canvas */
            user-select: none;
        }

        h1 { margin: 0 0 10px 0; font-size: 24px; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px #0ff; }

        .task-list { list-style: none; padding: 0; margin: 0; }
        .task-item {
            padding: 8px 0;
            border-bottom: 1px solid #333;
            color: #888;
            transition: all 0.3s;
            display: flex;
            align-items: center;
        }
        .task-item::before { content: '○'; margin-right: 10px; display: inline-block; width: 20px; }

        .task-item.active { color: #fff; font-weight: bold; transform: translateX(10px); }
        .task-item.active::before { content: '➤'; color: #ff00de; }

        .task-item.completed { color: #0f0; text-decoration: line-through; }
        .task-item.completed::before { content: '✓'; color: #0f0; }

        #victory-screen {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 4px solid #0f0;
            padding: 40px;
            text-align: center;
            color: #fff;
            box-shadow: 0 0 50px #0f0;
            z-index: 100;
        }
        #victory-screen h2 { font-size: 40px; margin: 0 0 20px 0; color: #0f0; }
        #victory-screen button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
        }
        #victory-screen button:hover { background: #fff; }

        #tooltip {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
            display: none;
            font-size: 14px;
            border: 1px solid white;
        }
    </style>
    <!-- Import Maps for clean Module Loading -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-layer">
        <h1>PC Builder <span style="color:#ff00de">Sim</span></h1>
        <p style="font-size: 12px; margin-bottom: 15px; color: #ccc;">Clique nas peças holográficas para montar.</p>
        <ul class="task-list" id="task-list">
            <!-- Items added by JS -->
        </ul>
    </div>

    <div id="victory-screen">
        <h2>SISTEMA OPERACIONAL!</h2>
        <p>Parabéns! Você montou seu PC Gamer com sucesso.</p>
        <button onclick="location.reload()">Montar Outro</button>
    </div>

    <div id="tooltip"></div>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuração da Cena ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a20);
        scene.fog = new THREE.FogExp2(0x1a1a20, 0.02);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 10, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Controles de Câmera
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 30;
        controls.maxPolarAngle = Math.PI / 2; // Não deixar ir para baixo do chão

        // Iluminação
        const ambientLight = new THREE.AmbientLight(0x404040, 1); // Luz suave
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // Luzes decorativas (RGB Gamer)
        const pointLight1 = new THREE.PointLight(0x00ffff, 2, 20);
        pointLight1.position.set(-5, 5, 5);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xff00de, 2, 20);
        pointLight2.position.set(5, 5, -5);
        scene.add(pointLight2);

        // Chão (Mesa)
        const planeGeometry = new THREE.PlaneGeometry(100, 100);
        const planeMaterial = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.1,
            metalness: 0.5
        });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        const gridHelper = new THREE.GridHelper(50, 50, 0x333333, 0x222222);
        scene.add(gridHelper);

        // --- Sistema de Peças e Lógica do Jogo ---

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Estado do Jogo
        let currentStepIndex = 0;
        const installedParts = [];

        // Definição das Peças
        // Cada peça tem: geometria, material, posição, rotação e nome
        const partsConfig = [
            {
                id: 'case',
                name: 'Gabinete (Torre)',
                type: 'base', // Peça inicial
                geometry: () => {
                    // Grupo complexo para o gabinete
                    const group = new THREE.Group();

                    // Estrutura principal (vazada)
                    const mat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.2 });
                    const glass = new THREE.MeshPhysicalMaterial({
                        color: 0x88ccff, metalness: 0.1, roughness: 0, transmission: 0.5, transparent: true, opacity: 0.3
                    });

                    // Fundo
                    const back = new THREE.Mesh(new THREE.BoxGeometry(1, 12, 12), mat);
                    back.position.set(-2, 6, 0);
                    back.castShadow = true; back.receiveShadow = true;
                    group.add(back);

                    // Base
                    const bottom = new THREE.Mesh(new THREE.BoxGeometry(5, 1, 12), mat);
                    bottom.position.set(0, 0.5, 0);
                    bottom.castShadow = true;
                    group.add(bottom);

                    // Topo
                    const top = new THREE.Mesh(new THREE.BoxGeometry(5, 1, 12), mat);
                    top.position.set(0, 11.5, 0);
                    top.castShadow = true;
                    group.add(top);

                    // Frente
                    const front = new THREE.Mesh(new THREE.BoxGeometry(5, 12, 1), mat);
                    front.position.set(0, 6, 5.5);
                    front.castShadow = true;
                    group.add(front);

                    return group;
                },
                position: { x: 0, y: 0, z: 0 }
            },
            {
                id: 'motherboard',
                name: 'Placa-mãe (ATX)',
                type: 'part',
                geometry: () => {
                    const group = new THREE.Group();
                    // PCB
                    const pcb = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 9, 9),
                        new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5 }) // PCB Preto fosco
                    );

                    // Detalhes da placa (VRM, Chipset - blocos decorativos)
                    const chipset = new THREE.Mesh(
                        new THREE.BoxGeometry(0.3, 2, 2),
                        new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8 })
                    );
                    chipset.position.set(0.1, -2, 2);

                    const ioShield = new THREE.Mesh(
                        new THREE.BoxGeometry(0.5, 8, 1),
                        new THREE.MeshStandardMaterial({ color: 0xaaaaaa })
                    );
                    ioShield.position.set(0, 0, -4);

                    group.add(pcb);
                    group.add(chipset);
                    group.add(ioShield);

                    // Circuitos (Textura processual simples usando canvas seria ideal, mas usaremos geometria simples)
                    return group;
                },
                position: { x: -1.4, y: 6, z: 0 } // Dentro do gabinete
            },
            {
                id: 'cpu',
                name: 'Processador (CPU)',
                type: 'part',
                geometry: () => {
                    return new THREE.Mesh(
                        new THREE.BoxGeometry(0.3, 1.5, 1.5),
                        new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 1, roughness: 0.3 })
                    );
                },
                position: { x: -1.2, y: 7.5, z: 1 } // Posição no socket
            },
            {
                id: 'ram',
                name: 'Memória RAM (2x 16GB)',
                type: 'part',
                geometry: () => {
                    const group = new THREE.Group();
                    const stick1 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 4, 0.2), new THREE.MeshStandardMaterial({color: 0xff0000, emissive: 0x550000}));
                    const stick2 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 4, 0.2), new THREE.MeshStandardMaterial({color: 0xff0000, emissive: 0x550000}));
                    stick1.position.z = 0;
                    stick2.position.z = 0.5;
                    group.add(stick1);
                    group.add(stick2);
                    return group;
                },
                position: { x: -1.0, y: 7.5, z: 2.5 } // Slots de RAM
            },
            {
                id: 'ssd',
                name: 'SSD NVMe M.2',
                type: 'part',
                geometry: () => {
                    return new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 0.8, 3),
                        new THREE.MeshStandardMaterial({ color: 0x111111 })
                    );
                },
                position: { x: -1.2, y: 5.5, z: 1 } // Slot M.2 abaixo da CPU
            },
            {
                id: 'cooler',
                name: 'CPU Cooler (RGB)',
                type: 'part',
                geometry: () => {
                    const group = new THREE.Group();
                    const block = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 1, 32), new THREE.MeshStandardMaterial({color: 0x222222}));
                    block.rotation.z = Math.PI / 2;

                    // Ventoinha RGB
                    const fan = new THREE.Mesh(new THREE.CylinderGeometry(1.4, 1.4, 0.1, 32), new THREE.MeshStandardMaterial({color: 0xffffff, emissive: 0x00ffff, emissiveIntensity: 1}));
                    fan.rotation.z = Math.PI / 2;
                    fan.position.x = 0.55;

                    group.add(block);
                    group.add(fan);
                    return group;
                },
                position: { x: -0.5, y: 7.5, z: 1 } // Em cima da CPU
            },
            {
                id: 'psu',
                name: 'Fonte de Alimentação (PSU)',
                type: 'part',
                geometry: () => {
                    return new THREE.Mesh(
                        new THREE.BoxGeometry(4, 2.5, 4),
                        new THREE.MeshStandardMaterial({ color: 0x111111 })
                    );
                },
                position: { x: 0, y: 2.3, z: -3.5 } // Parte inferior traseira
            },
            {
                id: 'gpu',
                name: 'Placa de Vídeo (GPU)',
                type: 'part',
                geometry: () => {
                    const group = new THREE.Group();
                    // Corpo da GPU
                    const body = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 2, 8),
                        new THREE.MeshStandardMaterial({ color: 0x333333 })
                    );

                    // Fans decorativas
                    const fanGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.1, 16);
                    const fanMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

                    const f1 = new THREE.Mesh(fanGeo, fanMat); f1.rotation.z = Math.PI/2; f1.position.x = 0.5; f1.position.z = -2;
                    const f2 = new THREE.Mesh(fanGeo, fanMat); f2.rotation.z = Math.PI/2; f2.position.x = 0.5; f2.position.z = 0;
                    const f3 = new THREE.Mesh(fanGeo, fanMat); f3.rotation.z = Math.PI/2; f3.position.x = 0.5; f3.position.z = 2;

                    // Strip RGB
                    const rgbStrip = new THREE.Mesh(new THREE.BoxGeometry(1.05, 0.1, 8), new THREE.MeshStandardMaterial({color: 0xffffff, emissive: 0xff00de}));
                    rgbStrip.position.y = 1;

                    group.add(body);
                    group.add(f1); group.add(f2); group.add(f3);
                    group.add(rgbStrip);
                    return group;
                },
                position: { x: -0.5, y: 5, z: 0 } // Slot PCIe
            },
            {
                id: 'glass_panel',
                name: 'Painel de Vidro',
                type: 'part',
                geometry: () => {
                    return new THREE.Mesh(
                        new THREE.BoxGeometry(0.1, 11, 11),
                        new THREE.MeshPhysicalMaterial({
                            color: 0xaaaaaa, metalness: 0, roughness: 0, transmission: 0.9, transparent: true, opacity: 0.3
                        })
                    );
                },
                position: { x: 2.5, y: 6.5, z: 0 } // Fecha o gabinete
            },
            {
                id: 'peripherals',
                name: 'Periféricos (Monitor, Teclado, Mouse)',
                type: 'part',
                geometry: () => {
                    const group = new THREE.Group();

                    // Monitor
                    const screen = new THREE.Mesh(new THREE.BoxGeometry(0.5, 9, 16), new THREE.MeshStandardMaterial({color: 0x111111}));
                    const display = new THREE.Mesh(new THREE.PlaneGeometry(15, 8), new THREE.MeshBasicMaterial({color: 0x0000ff})); // Tela azul inicial
                    display.rotation.y = -Math.PI/2;
                    display.position.x = -0.3;
                    screen.add(display);

                    const stand = new THREE.Mesh(new THREE.BoxGeometry(2, 6, 2), new THREE.MeshStandardMaterial({color: 0x222222}));
                    stand.position.y = -5;
                    screen.add(stand);

                    screen.position.set(10, 5, 0);
                    screen.rotation.y = -Math.PI / 6; // Levemente virado

                    // Teclado
                    const kb = new THREE.Mesh(new THREE.BoxGeometry(4, 0.5, 10), new THREE.MeshStandardMaterial({color: 0x222222}));
                    // RGB Teclado
                    const kbLight = new THREE.PointLight(0x00ff00, 1, 5);
                    kbLight.position.y = 1;
                    kb.add(kbLight);
                    kb.position.set(8, 0.5, 10);
                    kb.rotation.y = -Math.PI / 6;

                    // Mouse
                    const mouseObj = new THREE.Mesh(new THREE.CapsuleGeometry(1, 2, 4, 8), new THREE.MeshStandardMaterial({color: 0x333333}));
                    mouseObj.rotation.x = Math.PI / 2;
                    mouseObj.rotation.z = -Math.PI / 6;
                    mouseObj.position.set(8, 0.5, 18);

                    group.add(screen);
                    group.add(kb);
                    group.add(mouseObj);
                    return group;
                },
                position: { x: 10, y: 0, z: 10 } // Na mesa ao lado
            }
        ];

        // --- Configuração da UI e Inicialização ---

        const taskListEl = document.getElementById('task-list');
        const tooltipEl = document.getElementById('tooltip');
        let ghostMesh = null; // O holograma da peça atual

        function initUI() {
            partsConfig.forEach((part, index) => {
                const li = document.createElement('li');
                li.className = 'task-item';
                li.textContent = part.name;
                li.id = `task-${index}`;
                taskListEl.appendChild(li);
            });
            updateTaskUI();
        }

        function updateTaskUI() {
            // Limpa estilos
            document.querySelectorAll('.task-item').forEach(el => {
                el.classList.remove('active');
            });

            // Marca completados
            for(let i=0; i < currentStepIndex; i++) {
                const el = document.getElementById(`task-${i}`);
                if(el && !el.classList.contains('completed')) {
                    el.classList.add('completed');
                }
            }

            // Marca atual
            if (currentStepIndex < partsConfig.length) {
                const currentEl = document.getElementById(`task-${currentStepIndex}`);
                if (currentEl) currentEl.classList.add('active');

                spawnGhostPart(partsConfig[currentStepIndex]);
            } else {
                // Fim de jogo
                if(ghostMesh) { scene.remove(ghostMesh); ghostMesh = null; }
                document.getElementById('victory-screen').style.display = 'block';

                // Animação final de câmera
                const target = new THREE.Vector3(10, 5, 0); // Olha para o monitor
                new TWEEN.Tween(camera.position)
                    .to({ x: 25, y: 10, z: 25 }, 2000)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                controls.target.copy(target);
            }
        }

        // Cria o "Holograma" da peça atual para indicar onde clicar
        function spawnGhostPart(partConfig) {
            if (ghostMesh) scene.remove(ghostMesh);

            const geomGroup = partConfig.geometry();

            // Atravessa o grupo e muda material para "Holograma"
            geomGroup.traverse((child) => {
                if (child.isMesh) {
                    child.material = new THREE.MeshBasicMaterial({
                        color: 0x00ff00,
                        transparent: true,
                        opacity: 0.3,
                        wireframe: true
                    });
                }
            });

            ghostMesh = geomGroup;
            ghostMesh.position.set(partConfig.position.x, partConfig.position.y, partConfig.position.z);

            // Animação de flutuar levemente (será feito no loop)
            ghostMesh.userData = {
                baseY: partConfig.position.y,
                isGhost: true,
                partIndex: currentStepIndex
            };

            scene.add(ghostMesh);
        }

        function installPart() {
            if (!ghostMesh) return;

            // Remove ghost
            scene.remove(ghostMesh);
            ghostMesh = null;

            // Cria peça real
            const partConfig = partsConfig[currentStepIndex];
            const realPart = partConfig.geometry();

            // Seta posição
            realPart.position.set(partConfig.position.x, partConfig.position.y, partConfig.position.z);

            // Efeito de "Pop" ao aparecer
            realPart.scale.set(0,0,0);

            scene.add(realPart);
            installedParts.push(realPart);

            // Animação de escala simples (interpolação manual no animate seria melhor, mas vamos usar logica simples aqui)
            let s = 0;
            const grow = setInterval(() => {
                s += 0.1;
                realPart.scale.set(s,s,s);
                if(s >= 1) {
                    realPart.scale.set(1,1,1);
                    clearInterval(grow);
                }
            }, 16);

            currentStepIndex++;
            updateTaskUI();
        }

        // --- Inputs ---

        window.addEventListener('mousemove', onMouseMove, false);
        window.addEventListener('click', onClick, false);

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Tooltip logic
            raycaster.setFromCamera(mouse, camera);
            if (ghostMesh) {
                const intersects = raycaster.intersectObject(ghostMesh, true);
                if (intersects.length > 0) {
                    document.body.style.cursor = 'pointer';
                    tooltipEl.style.display = 'block';
                    tooltipEl.style.left = event.clientX + 15 + 'px';
                    tooltipEl.style.top = event.clientY + 15 + 'px';
                    tooltipEl.textContent = "Instalar: " + partsConfig[currentStepIndex].name;
                } else {
                    document.body.style.cursor = 'default';
                    tooltipEl.style.display = 'none';
                }
            }
        }

        function onClick(event) {
            if(currentStepIndex >= partsConfig.length) return;

            raycaster.setFromCamera(mouse, camera);

            // Verifica se clicou no Ghost
            if (ghostMesh) {
                const intersects = raycaster.intersectObject(ghostMesh, true);
                if (intersects.length > 0) {
                    installPart();
                }
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Loop Principal ---

        // Simples biblioteca de Tween interna para não depender de externa
        const TWEEN = {
            Tween: function(obj) {
                this.obj = obj;
                this.target = {};
                this.duration = 1000;
                this.easingFn = (t) => t;

                this.to = function(target, duration) {
                    this.target = target;
                    this.duration = duration;
                    return this;
                }
                this.easing = function(fn) {
                    this.easingFn = fn;
                    return this;
                }
                this.start = function() {
                    const startValues = {};
                    for(let key in this.target) startValues[key] = this.obj[key];
                    const startTime = Date.now();

                    const animate = () => {
                        const now = Date.now();
                        let progress = (now - startTime) / this.duration;
                        if(progress > 1) progress = 1;

                        const val = this.easingFn(progress);

                        for(let key in this.target) {
                            this.obj[key] = startValues[key] + (this.target[key] - startValues[key]) * val;
                        }

                        if(progress < 1) requestAnimationFrame(animate);
                    };
                    animate();
                }
            },
            Easing: {
                Quadratic: { Out: (t) => t * (2 - t) }
            }
        };

        function animate() {
            requestAnimationFrame(animate);

            controls.update();

            // Animação do Ghost (Pulsar/Flutuar)
            if (ghostMesh) {
                const time = Date.now() * 0.005;
                ghostMesh.position.y = ghostMesh.userData.baseY + Math.sin(time) * 0.1;
                ghostMesh.rotation.y = Math.sin(time * 0.5) * 0.05;

                // Piscar opacidade
                ghostMesh.traverse((child) => {
                    if (child.isMesh) {
                        child.material.opacity = 0.3 + Math.sin(time * 3) * 0.15;
                    }
                });
            }

            // Animar fans da GPU se instalada
            // (Procura pela GPU nos installedParts - index 7 é GPU baseada na ordem, mas melhor procurar pelo ID se fosse complexo)
            if (installedParts.length > 7) {
                // Assumindo que a GPU é o item de index 7 na ordem de inserção
                // Mas a lógica de push é sequencial. Vamos simplificar:
                // Se o jogo acabou ou GPU instalada, animar.
            }

            renderer.render(scene, camera);
        }

        // Start
        initUI();
        // Pré-instala a primeira peça (Gabinete) se quiser que comece com ela,
        // mas o jogo pede para clicar. Vamos deixar o usuário clicar no gabinete fantasma primeiro para começar.
        // Se preferir que o gabinete já exista, chamaria installPart() uma vez aqui.
        // Vamos deixar o usuário clicar para criar a base.

        animate();

    </script>
</body>
</html>