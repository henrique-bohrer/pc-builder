<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PC Builder 3D - Simulador de Montagem</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0ff;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 2px solid #0ff;
            border-radius: 10px;
            box-shadow: 0 0 15px #0ff;
            max-width: 300px;
            pointer-events: none; /* Let clicks pass through to canvas */
            user-select: none;
        }

        h1 { margin: 0 0 10px 0; font-size: 24px; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px #0ff; }

        .task-list { list-style: none; padding: 0; margin: 0; }
        .task-item {
            padding: 8px 0;
            border-bottom: 1px solid #333;
            color: #888;
            transition: all 0.3s;
            display: flex;
            align-items: center;
        }
        .task-item::before { content: '○'; margin-right: 10px; display: inline-block; width: 20px; }

        .task-item.active { color: #fff; font-weight: bold; transform: translateX(10px); }
        .task-item.active::before { content: '➤'; color: #ff00de; }

        .task-item.completed { color: #0f0; text-decoration: line-through; }
        .task-item.completed::before { content: '✓'; color: #0f0; }

        #victory-screen {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 4px solid #0f0;
            padding: 40px;
            text-align: center;
            color: #fff;
            box-shadow: 0 0 50px #0f0;
            z-index: 100;
        }
        #victory-screen h2 { font-size: 40px; margin: 0 0 20px 0; color: #0f0; }
        #victory-screen button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
        }
        #victory-screen button:hover { background: #fff; }

        /* Configuration Screen */
        #config-screen {
            position: absolute;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background: #111;
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        #config-screen h2 {
            font-size: 36px; margin-bottom: 30px; text-transform: uppercase; color: #0ff;
            text-shadow: 0 0 20px #0ff;
        }
        .config-group { margin-bottom: 20px; text-align: left; width: 300px; }
        .config-group label { display: block; margin-bottom: 5px; color: #aaa; }
        .config-group select {
            width: 100%; padding: 10px; background: #222; border: 1px solid #444; color: #fff;
            font-size: 16px; border-radius: 5px;
        }
        #start-btn {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 20px;
            background: #0ff;
            color: #000;
            border: none;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            transition: all 0.2s;
        }
        #start-btn:hover { background: #fff; box-shadow: 0 0 30px rgba(0, 255, 255, 0.8); }

        #tooltip {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
            display: none;
            font-size: 14px;
            border: 1px solid white;
        }
    </style>
    <!-- Import Maps for clean Module Loading -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="config-screen">
        <h2>Nova Montagem</h2>

        <div class="config-group">
            <label>Tipo de PC</label>
            <select id="pc-type">
                <option value="gamer">Gamer (Alto Desempenho)</option>
                <option value="casual">Casual (Uso Doméstico)</option>
                <option value="office">Escritório (Básico)</option>
            </select>
        </div>

        <div class="config-group">
            <label>Teclado</label>
            <select id="kb-type">
                <option value="mechanical">Mecânico RGB</option>
                <option value="standard">Padrão</option>
            </select>
        </div>

        <div class="config-group">
            <label>Mouse</label>
            <select id="mouse-type">
                <option value="gaming">Gamer</option>
                <option value="standard">Padrão</option>
            </select>
        </div>

        <button id="start-btn">Iniciar Montagem</button>
    </div>

    <div id="ui-layer" style="display:none;">
        <h1>PC Builder <span style="color:#ff00de">Sim</span></h1>
        <p style="font-size: 12px; margin-bottom: 15px; color: #ccc;">Clique nas peças holográficas para montar.</p>
        <ul class="task-list" id="task-list">
            <!-- Items added by JS -->
        </ul>
    </div>

    <div id="victory-screen">
        <h2>SISTEMA OPERACIONAL!</h2>
        <p>Parabéns! Você montou seu PC Gamer com sucesso.</p>
        <button onclick="location.reload()">Montar Outro</button>
    </div>

    <div id="tooltip"></div>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuração da Cena ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a20);
        scene.fog = new THREE.FogExp2(0x1a1a20, 0.02);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 10, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Controles de Câmera
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 30;
        controls.maxPolarAngle = Math.PI / 2; // Não deixar ir para baixo do chão

        // Iluminação
        const ambientLight = new THREE.AmbientLight(0x404040, 1); // Luz suave
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // Luzes decorativas (RGB Gamer)
        const pointLight1 = new THREE.PointLight(0x00ffff, 2, 20);
        pointLight1.position.set(-5, 5, 5);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xff00de, 2, 20);
        pointLight2.position.set(5, 5, -5);
        scene.add(pointLight2);

        // Chão (Mesa)
        const planeGeometry = new THREE.PlaneGeometry(100, 100);
        const planeMaterial = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.1,
            metalness: 0.5
        });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        const gridHelper = new THREE.GridHelper(50, 50, 0x333333, 0x222222);
        scene.add(gridHelper);

        // --- Sistema de Peças e Lógica do Jogo ---

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Estado do Jogo
        let currentStepIndex = 0;
        const installedParts = [];
        let gameConfig = { type: 'gamer', keyboard: 'mechanical', mouse: 'gaming' };

        // Definição das Peças
        let partsConfig = [];

        function generatePartsConfig(settings) {
            const list = [];

            // --- GABINETE ---
            let caseColor = 0x222222;
            let caseGlassOpacity = 0.3;
            if(settings.type === 'office') { caseColor = 0xcccccc; caseGlassOpacity = 0.0; } // Office cinza e fechado? Vamos deixar vidro para todos mas mudar cor
            if(settings.type === 'casual') { caseColor = 0xffffff; }

            list.push({
                id: 'case',
                name: 'Gabinete (Torre)',
                type: 'base',
                geometry: () => {
                    const group = new THREE.Group();
                    const mat = new THREE.MeshStandardMaterial({ color: caseColor, metalness: 0.5, roughness: 0.5 });
                    // Fundo
                    const back = new THREE.Mesh(new THREE.BoxGeometry(1, 12, 12), mat); back.position.set(-2, 6, 0);
                    back.castShadow = true; back.receiveShadow = true; group.add(back);
                    // Base
                    const bottom = new THREE.Mesh(new THREE.BoxGeometry(5, 1, 12), mat); bottom.position.set(0, 0.5, 0);
                    bottom.castShadow = true; group.add(bottom);
                    // Topo
                    const top = new THREE.Mesh(new THREE.BoxGeometry(5, 1, 12), mat); top.position.set(0, 11.5, 0);
                    top.castShadow = true; group.add(top);
                    // Frente
                    const front = new THREE.Mesh(new THREE.BoxGeometry(5, 12, 1), mat); front.position.set(0, 6, 5.5);
                    front.castShadow = true; group.add(front);
                    return group;
                },
                position: { x: 0, y: 0, z: 0 }
            });

            // --- MOTHERBOARD ---
            list.push({
                id: 'motherboard',
                name: 'Placa-mãe (ATX)',
                type: 'part',
                geometry: () => {
                    const group = new THREE.Group();
                    const pcb = new THREE.Mesh(new THREE.BoxGeometry(0.2, 9, 9), new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5 }));
                    const chipset = new THREE.Mesh(new THREE.BoxGeometry(0.3, 2, 2), new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8 }));
                    chipset.position.set(0.1, -2, 2);
                    const ioShield = new THREE.Mesh(new THREE.BoxGeometry(0.5, 8, 1), new THREE.MeshStandardMaterial({ color: 0xaaaaaa }));
                    ioShield.position.set(0, 0, -4);
                    group.add(pcb); group.add(chipset); group.add(ioShield);
                    return group;
                },
                position: { x: -1.4, y: 6, z: 0 }
            });

            // --- CPU ---
            list.push({
                id: 'cpu',
                name: 'Processador (CPU)',
                type: 'part',
                geometry: () => {
                    return new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.5, 1.5), new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 1, roughness: 0.3 }));
                },
                position: { x: -1.2, y: 7.5, z: 1 }
            });

            // --- RAM ---
            // Gamer: RGB vermelho; Office: Verde simples; Casual: Preto
            let ramColor = 0x006400; // Verde padrão
            let ramEmissive = 0x000000;
            if(settings.type === 'gamer') { ramColor = 0xff0000; ramEmissive = 0x550000; }
            if(settings.type === 'casual') { ramColor = 0x111111; }

            list.push({
                id: 'ram',
                name: 'Memória RAM (2x)',
                type: 'part',
                geometry: () => {
                    const group = new THREE.Group();
                    const stick1 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 4, 0.2), new THREE.MeshStandardMaterial({color: ramColor, emissive: ramEmissive}));
                    const stick2 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 4, 0.2), new THREE.MeshStandardMaterial({color: ramColor, emissive: ramEmissive}));
                    stick1.position.z = 0; stick2.position.z = 0.5;
                    group.add(stick1); group.add(stick2);
                    return group;
                },
                position: { x: -1.0, y: 7.5, z: 2.5 }
            });

            // --- SSD ---
            list.push({
                id: 'ssd',
                name: 'SSD NVMe M.2',
                type: 'part',
                geometry: () => {
                    return new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 3), new THREE.MeshStandardMaterial({ color: 0x111111 }));
                },
                position: { x: -1.2, y: 5.5, z: 1 }
            });

            // --- COOLER ---
            // Gamer: Tower RGB; Office: Low Profile; Casual: Tower simples
            list.push({
                id: 'cooler',
                name: 'CPU Cooler',
                type: 'part',
                geometry: () => {
                    const group = new THREE.Group();
                    if(settings.type === 'office') {
                        // Low profile
                        const block = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 0.5, 32), new THREE.MeshStandardMaterial({color: 0xaaaaaa}));
                        block.rotation.z = Math.PI / 2;
                        const fan = new THREE.Mesh(new THREE.CylinderGeometry(1.4, 1.4, 0.1, 32), new THREE.MeshStandardMaterial({color: 0x333333}));
                        fan.rotation.z = Math.PI / 2; fan.position.x = 0.3;
                        group.add(block); group.add(fan);
                    } else {
                        // Tower
                        const block = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 1, 32), new THREE.MeshStandardMaterial({color: 0x222222}));
                        block.rotation.z = Math.PI / 2;

                        let fanColor = 0xffffff;
                        let fanEmissive = 0x000000;
                        if(settings.type === 'gamer') { fanEmissive = 0x00ffff; } // RGB

                        const fan = new THREE.Mesh(new THREE.CylinderGeometry(1.4, 1.4, 0.1, 32), new THREE.MeshStandardMaterial({color: fanColor, emissive: fanEmissive, emissiveIntensity: 1}));
                        fan.rotation.z = Math.PI / 2; fan.position.x = 0.55;
                        group.add(block); group.add(fan);
                    }
                    return group;
                },
                position: { x: -0.5, y: 7.5, z: 1 }
            });

            // --- PSU ---
            list.push({
                id: 'psu',
                name: 'Fonte de Alimentação',
                type: 'part',
                geometry: () => {
                    return new THREE.Mesh(new THREE.BoxGeometry(4, 2.5, 4), new THREE.MeshStandardMaterial({ color: 0x111111 }));
                },
                position: { x: 0, y: 2.3, z: -3.5 }
            });

            // --- GPU ---
            // Office: Sem GPU dedicada (Integrada)
            if(settings.type !== 'office') {
                list.push({
                    id: 'gpu',
                    name: 'Placa de Vídeo (GPU)',
                    type: 'part',
                    geometry: () => {
                        const group = new THREE.Group();
                        const body = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 8), new THREE.MeshStandardMaterial({ color: 0x333333 }));

                        // Fans
                        const fanGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.1, 16);
                        const fanMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
                        const f1 = new THREE.Mesh(fanGeo, fanMat); f1.rotation.z = Math.PI/2; f1.position.x = 0.5; f1.position.z = -2;
                        const f2 = new THREE.Mesh(fanGeo, fanMat); f2.rotation.z = Math.PI/2; f2.position.x = 0.5; f2.position.z = 0;
                        const f3 = new THREE.Mesh(fanGeo, fanMat); f3.rotation.z = Math.PI/2; f3.position.x = 0.5; f3.position.z = 2;

                        group.add(body); group.add(f1); group.add(f2); group.add(f3);

                        if(settings.type === 'gamer') {
                            const rgbStrip = new THREE.Mesh(new THREE.BoxGeometry(1.05, 0.1, 8), new THREE.MeshStandardMaterial({color: 0xffffff, emissive: 0xff00de}));
                            rgbStrip.position.y = 1;
                            group.add(rgbStrip);
                        }

                        return group;
                    },
                    position: { x: -0.5, y: 5, z: 0 }
                });
            }

            // --- PAINEL DE VIDRO/LATERAL ---
            list.push({
                id: 'glass_panel',
                name: settings.type === 'office' ? 'Painel Lateral' : 'Painel de Vidro',
                type: 'part',
                geometry: () => {
                    let material;
                    if(settings.type === 'office') {
                        // Painel solido
                        material = new THREE.MeshStandardMaterial({ color: caseColor, metalness: 0.5, roughness: 0.5 });
                    } else {
                        // Vidro
                        material = new THREE.MeshPhysicalMaterial({ color: 0xaaaaaa, metalness: 0, roughness: 0, transmission: 0.9, transparent: true, opacity: 0.3 });
                    }
                    return new THREE.Mesh(new THREE.BoxGeometry(0.1, 11, 11), material);
                },
                position: { x: 2.5, y: 6.5, z: 0 }
            });

            // --- PERIFÉRICOS ---
            list.push({
                id: 'peripherals',
                name: 'Periféricos',
                type: 'part',
                geometry: () => {
                    const group = new THREE.Group();

                    // Monitor
                    const screen = new THREE.Mesh(new THREE.BoxGeometry(0.5, 9, 16), new THREE.MeshStandardMaterial({color: 0x111111}));
                    const display = new THREE.Mesh(new THREE.PlaneGeometry(15, 8), new THREE.MeshBasicMaterial({color: 0x0000ff}));
                    display.rotation.y = -Math.PI/2; display.position.x = -0.3; screen.add(display);
                    const stand = new THREE.Mesh(new THREE.BoxGeometry(2, 6, 2), new THREE.MeshStandardMaterial({color: 0x222222}));
                    stand.position.y = -5; screen.add(stand);
                    screen.position.set(10, 5, 0); screen.rotation.y = -Math.PI / 6;
                    group.add(screen);

                    // Teclado
                    const kb = new THREE.Mesh(new THREE.BoxGeometry(4, 0.5, 10), new THREE.MeshStandardMaterial({color: settings.keyboard === 'mechanical' ? 0x222222 : 0xdddddd}));
                    kb.position.set(8, 0.5, 10); kb.rotation.y = -Math.PI / 6;

                    if(settings.keyboard === 'mechanical') {
                        const kbLight = new THREE.PointLight(0x00ff00, 1, 5); kbLight.position.y = 1; kb.add(kbLight);
                    }
                    group.add(kb);

                    // Mouse
                    let mouseGeo;
                    if(settings.mouse === 'gaming') {
                         mouseGeo = new THREE.CapsuleGeometry(1, 2, 4, 8);
                    } else {
                         mouseGeo = new THREE.BoxGeometry(1.5, 1, 3);
                    }
                    const mouseObj = new THREE.Mesh(mouseGeo, new THREE.MeshStandardMaterial({color: settings.mouse === 'gaming' ? 0x333333 : 0xeeeeee}));
                    if(settings.mouse === 'gaming') {
                        mouseObj.rotation.x = Math.PI / 2; mouseObj.rotation.z = -Math.PI / 6;
                    } else {
                        mouseObj.rotation.y = -Math.PI / 6;
                    }
                    mouseObj.position.set(8, 0.5, 18);
                    group.add(mouseObj);

                    return group;
                },
                position: { x: 10, y: 0, z: 10 }
            });

            return list;
        }

        // --- Configuração da UI e Inicialização ---

        const taskListEl = document.getElementById('task-list');
        const tooltipEl = document.getElementById('tooltip');
        let ghostMesh = null; // O holograma da peça atual

        function initUI() {
            partsConfig.forEach((part, index) => {
                const li = document.createElement('li');
                li.className = 'task-item';
                li.textContent = part.name;
                li.id = `task-${index}`;
                taskListEl.appendChild(li);
            });
            updateTaskUI();
        }

        function updateTaskUI() {
            // Limpa estilos
            document.querySelectorAll('.task-item').forEach(el => {
                el.classList.remove('active');
            });

            // Marca completados
            for(let i=0; i < currentStepIndex; i++) {
                const el = document.getElementById(`task-${i}`);
                if(el && !el.classList.contains('completed')) {
                    el.classList.add('completed');
                }
            }

            // Marca atual
            if (currentStepIndex < partsConfig.length) {
                const currentEl = document.getElementById(`task-${currentStepIndex}`);
                if (currentEl) currentEl.classList.add('active');

                spawnGhostPart(partsConfig[currentStepIndex]);
            } else {
                // Fim de jogo
                if(ghostMesh) { scene.remove(ghostMesh); ghostMesh = null; }
                document.getElementById('victory-screen').style.display = 'block';

                // Animação final de câmera
                const target = new THREE.Vector3(10, 5, 0); // Olha para o monitor
                new TWEEN.Tween(camera.position)
                    .to({ x: 25, y: 10, z: 25 }, 2000)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                controls.target.copy(target);
            }
        }

        // Cria o "Holograma" da peça atual para indicar onde clicar
        function spawnGhostPart(partConfig) {
            if (ghostMesh) scene.remove(ghostMesh);

            const geomGroup = partConfig.geometry();

            // Atravessa o grupo e muda material para "Holograma"
            geomGroup.traverse((child) => {
                if (child.isMesh) {
                    child.material = new THREE.MeshBasicMaterial({
                        color: 0x00ff00,
                        transparent: true,
                        opacity: 0.3,
                        wireframe: true
                    });
                }
            });

            ghostMesh = geomGroup;
            ghostMesh.position.set(partConfig.position.x, partConfig.position.y, partConfig.position.z);

            // Animação de flutuar levemente (será feito no loop)
            ghostMesh.userData = {
                baseY: partConfig.position.y,
                isGhost: true,
                partIndex: currentStepIndex
            };

            scene.add(ghostMesh);
        }

        function installPart() {
            if (!ghostMesh) return;

            // Remove ghost
            scene.remove(ghostMesh);
            ghostMesh = null;

            // Cria peça real
            const partConfig = partsConfig[currentStepIndex];
            const realPart = partConfig.geometry();

            // Seta posição
            realPart.position.set(partConfig.position.x, partConfig.position.y, partConfig.position.z);

            // Efeito de "Pop" ao aparecer
            realPart.scale.set(0,0,0);

            scene.add(realPart);
            installedParts.push(realPart);

            // Animação de escala simples (interpolação manual no animate seria melhor, mas vamos usar logica simples aqui)
            let s = 0;
            const grow = setInterval(() => {
                s += 0.1;
                realPart.scale.set(s,s,s);
                if(s >= 1) {
                    realPart.scale.set(1,1,1);
                    clearInterval(grow);
                }
            }, 16);

            currentStepIndex++;
            updateTaskUI();
        }

        // --- Inputs ---

        window.addEventListener('mousemove', onMouseMove, false);
        window.addEventListener('click', onClick, false);

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Tooltip logic
            raycaster.setFromCamera(mouse, camera);
            if (ghostMesh) {
                const intersects = raycaster.intersectObject(ghostMesh, true);
                if (intersects.length > 0) {
                    document.body.style.cursor = 'pointer';
                    tooltipEl.style.display = 'block';
                    tooltipEl.style.left = event.clientX + 15 + 'px';
                    tooltipEl.style.top = event.clientY + 15 + 'px';
                    tooltipEl.textContent = "Instalar: " + partsConfig[currentStepIndex].name;
                } else {
                    document.body.style.cursor = 'default';
                    tooltipEl.style.display = 'none';
                }
            }
        }

        function onClick(event) {
            if(currentStepIndex >= partsConfig.length) return;

            raycaster.setFromCamera(mouse, camera);

            // Verifica se clicou no Ghost
            if (ghostMesh) {
                const intersects = raycaster.intersectObject(ghostMesh, true);
                if (intersects.length > 0) {
                    installPart();
                }
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Loop Principal ---

        // Simples biblioteca de Tween interna para não depender de externa
        const TWEEN = {
            Tween: function(obj) {
                this.obj = obj;
                this.target = {};
                this.duration = 1000;
                this.easingFn = (t) => t;

                this.to = function(target, duration) {
                    this.target = target;
                    this.duration = duration;
                    return this;
                }
                this.easing = function(fn) {
                    this.easingFn = fn;
                    return this;
                }
                this.start = function() {
                    const startValues = {};
                    for(let key in this.target) startValues[key] = this.obj[key];
                    const startTime = Date.now();

                    const animate = () => {
                        const now = Date.now();
                        let progress = (now - startTime) / this.duration;
                        if(progress > 1) progress = 1;

                        const val = this.easingFn(progress);

                        for(let key in this.target) {
                            this.obj[key] = startValues[key] + (this.target[key] - startValues[key]) * val;
                        }

                        if(progress < 1) requestAnimationFrame(animate);
                    };
                    animate();
                }
            },
            Easing: {
                Quadratic: { Out: (t) => t * (2 - t) }
            }
        };

        function animate() {
            requestAnimationFrame(animate);

            controls.update();

            // Animação do Ghost (Pulsar/Flutuar)
            if (ghostMesh) {
                const time = Date.now() * 0.005;
                ghostMesh.position.y = ghostMesh.userData.baseY + Math.sin(time) * 0.1;
                ghostMesh.rotation.y = Math.sin(time * 0.5) * 0.05;

                // Piscar opacidade
                ghostMesh.traverse((child) => {
                    if (child.isMesh) {
                        child.material.opacity = 0.3 + Math.sin(time * 3) * 0.15;
                    }
                });
            }

            // Animar fans da GPU se instalada
            // (Procura pela GPU nos installedParts - index 7 é GPU baseada na ordem, mas melhor procurar pelo ID se fosse complexo)
            if (installedParts.length > 7) {
                // Assumindo que a GPU é o item de index 7 na ordem de inserção
                // Mas a lógica de push é sequencial. Vamos simplificar:
                // Se o jogo acabou ou GPU instalada, animar.
            }

            renderer.render(scene, camera);
        }

        // Start Game Logic
        document.getElementById('start-btn').addEventListener('click', () => {
            gameConfig.type = document.getElementById('pc-type').value;
            gameConfig.keyboard = document.getElementById('kb-type').value;
            gameConfig.mouse = document.getElementById('mouse-type').value;

            document.getElementById('config-screen').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'block';

            // Gera a lista de peças baseada nas escolhas
            partsConfig = generatePartsConfig(gameConfig);

            initUI();
        });

        // initUI(); // Called by button now

        animate();

    </script>
</body>
</html>